<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>public</access>
        <active>true</active>
        <api_name>x_376096_mplc.MPLCWorker</api_name>
        <caller_access/>
        <client_callable>false</client_callable>
        <description>This script include handles all background processing work</description>
        <name>MPLCWorker</name>
        <script><![CDATA[/* global Class, global, GlideRecord, gs, sn_cc, sn_ws, GlideScopedEvaluator */
/* eslint no-undef: "error" */
var MPLCWorker = Class.create();
MPLCWorker.prototype = {
    initialize: function (progressID) {
		if (progressID) {
			this.progress_id = progressID;
		} else {
			this.progress_id = new global.AJAXExecutionTracker().getLastRunning();
		}
    },
	
	verifySourceAlias: function (aliasGr) {
		const result = {
			status: 'error',
			message: ''
		};
		
		const provider = new sn_cc.ConnectionInfoProvider();
		const sourceConn = provider.getConnectionInfo(aliasGr.sys_id);
		const sourceAttrs = sourceConn.getExtendedAttributes(); 
		if (sourceAttrs.type == 'source') {
			const targetConn = provider.getConnectionInfo(sourceAttrs.target);
			if (targetConn) {
				const targetAttrs = targetConn.getExtendedAttributes();
				if (targetAttrs.type == 'target') {
					const targetURL = targetConn.getAttribute('connection_url');
					const sourceURL = sourceConn.getAttribute('connection_url');
					if (targetURL.startsWith(sourceURL) || sourceURL.startsWith(targetURL)) {
						const apiKey = targetConn.getCredentialAttribute('api_key');
						const password = targetConn.getCredentialAttribute('password');
						if (apiKey || password) {
							result.connection = {
								token: apiKey || password,
								credential_sys_id: targetConn.getCredentialAttribute('sys_id'),
								attrs: targetAttrs
							};
						
							result.status = 'success';
						} else {
							result.message = 'Target has no Credential configured';
						}
					} else {
						result.message = 'Source and Target API Endpoints incompatible';
					}
				} else {
					result.message = 'Target Connection Alias on Source is not of type "Target"';
				}
			} else {
				result.message = 'No Target Connection Alias configured on Source';
			}
		} else {
			result.message = 'Provided Connection Alias is not of type "Source"';
		}
		
		return result;
	},
	
	installGitApp: function (aliasGr, repo) {
		if (repo.clone_url) {
			const verifyRes = this.verifySourceAlias(aliasGr);
			if (verifyRes.status == 'success') {
				let repoData = getRepoData(verifyRes.connection.token, repo.url);
				if (repoData) {
					if (repoData.fork && repoData.clone_url) {
						this._trackerSuccess('Repository already forked!', { 
							repo_url: repoData.clone_url,
							branch: repoData.default_branch,
							credential_sys_id: verifyRes.connection.credential_sys_id
						});
					} else {
						this._trackerFail('The repo already exists, but is not a fork or was forked from a different source');
					}
				} else {
					const repoURL = forkRepo(verifyRes.connection.token, repo, verifyRes.connection.attrs);
					if (repoURL) {
						let repoData = null;
						do {
							this._execScript('global', 'gs.sleep(1000)');
							repoData = getRepoData(verifyRes.connection.token, repoURL);
						} while (repoData == null && !this._trackerIsCancelled());

						if (repoData) {
							this._trackerSuccess('Repository successfully forked', { 
								repo_url: repoData.clone_url,
								branch_name: repoData.default_branch,
								credential_sys_id: verifyRes.connection.credential_sys_id
							});
						}
					} else {
						this._trackerFail('Failed to fork repo!');
					}
				}
			} else {
				this._trackerFail(verifyRes.message);
			}
		} else {
			this._trackerFail('Clone URL missing');
		}
		
		function getRepoData(token, repo) {
			let sm = new sn_ws.RESTMessageV2();
			sm.setRequestHeader('Accept', 'application/vnd.github+json');
			sm.setRequestHeader('Authorization', 'Bearer ' + token);
			sm.setHttpMethod('get');
			sm.setEndpoint(repo.url);
			const response = sm.execute();
			if (response.getStatusCode() == 200) {
				const body = JSON.parse(response.getBody());
				const repo = {
					fork: body.fork,
					clone_url: body.clone_url,
					default_branch: body.default_branch
				};
				
				if (body.parent) {
					repo.parent = {
						clone_url: body.parent.clone_url
					};
				}
				
				return repo;
			}
			
			return null;
		}
			
		function forkRepo(token, repo, connAttrs) {
			let sm = new sn_ws.RESTMessageV2();
			sm.setRequestHeader('Accept', 'application/vnd.github+json');
			sm.setRequestHeader('Authorization', 'Bearer ' + token);
			sm.setHttpMethod('post');
			sm.setEndpoint(repo.forks_url);

			const req = {
				default_branch_only: true
			};

			if (connAttrs.github_type == 'organization') {
				req.organization = connAttrs.github_name;
			}

			sm.setRequestBody(JSON.stringify(req));
			const response = sm.execute();
			if (response.getStatusCode() == 202) {
				const body = JSON.parse(response.getBody());
				return body.url;
			}
			
			return null;
		}
	},
	
	verifyGitApp: function (aliasGr, repo) {
		const repoConfigGr = new GlideRecord('sys_repo_config');
		repoConfigGr.addQuery('sys_app', repo.app.sys_id);
		repoConfigGr.setLimit(1);
		repoConfigGr.query();
		const repoConfigExists = repoConfigGr.hasNext();
		
		const appGr = new GlideRecord('sys_app');
		appGr.addQuery('sys_id', repo.app.sys_id);
		appGr.setLimit(1);
		appGr.query();
	},
	
	_trackerUpdateMessage: function (message) {
		const globalTracker = new global.AJAXExecutionTracker();
		const objs = {
			sysparm_tracker_id: this.worker_id,
			sysparm_message: message
		};
		globalTracker.getParameter = function (n) { return objs[n]; };
		globalTracker.updateMessage();
	},
	
	_trackerIsCancelled: function () {
		const state = {
			PENDING: 0,
			RUNNING: 1,
			SUCCESSFULL: 2,
			FAILED: 3,
			CANCELLED: 4
		};
		
		const trackerGr = new GlideRecord('sys_execution_tracker');
		trackerGr.addQuery('sys_id', this.worker_id);
		trackerGr.addQuery('state', state.CANCELLED);
		trackerGr.setLimit(1);
		trackerGr.query();
		return trackerGr.hasNext();
	},
	
	_trackerUpdatePercentComplete: function (percentage) {
		const globalTracker = new global.AJAXExecutionTracker();
		const objs = {
			sysparm_tracker_id: this.worker_id,
			sysparm_percent_complete: percentage
		};
		globalTracker.getParameter = function (n) { return objs[n]; };
		globalTracker.updatePercentComplete();
	},
	
	_trackerSuccess: function (message, result) {		
		this._updateResult(result);
		
		const globalTracker = new global.AJAXExecutionTracker();
		const objs = {
			sysparm_tracker_id: this.worker_id,
			sysparm_message: message
		};
		globalTracker.getParameter = function (n) { return objs[n]; };
		globalTracker.success();
	},

	_trackerFail: function (message, result) {
		this._updateResult(result);
		
		const globalTracker = new global.AJAXExecutionTracker();
		const objs = {
			sysparm_tracker_id: this.worker_id,
			sysparm_message: message
		};
		globalTracker.getParameter = function (n) { return objs[n]; };
		globalTracker.fail();
	},

	_updateResult: function (result) {
		if (result) {
			const globalTracker = new global.AJAXExecutionTracker();
			const tracker = globalTracker._getTracker(this.worker_id);
			tracker.updateResult(result);
		}
	},
	
	_runScript: function (scope, script, vars) {
		const scriptGr = new GlideRecord('sys_rte_eb_script_operation');
		scriptGr.addQuery('sys_id', '26659daf97fb39503c2d3f56f053af90');
		scriptGr.setLimit(1);
		scriptGr.query();
		if (scriptGr.next()) {
			scriptGr.sys_scope = scope;
			scriptGr.script = script;
			const gse = new GlideScopedEvaluator();
			return gse.evaluateScript(scriptGr, 'script', vars);
		}

		return null;
	},

    type: 'MPLCWorker'
};]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>markus.kraus</sys_created_by>
        <sys_created_on>2024-01-23 10:54:13</sys_created_on>
        <sys_id>9f6c5a5397bff5503c2d3f56f053af45</sys_id>
        <sys_mod_count>41</sys_mod_count>
        <sys_name>MPLCWorker</sys_name>
        <sys_package display_value="Marketplace Client" source="x_376096_mplc">2fe28b4497bf39103c2d3f56f053af4e</sys_package>
        <sys_policy/>
        <sys_scope display_value="Marketplace Client">2fe28b4497bf39103c2d3f56f053af4e</sys_scope>
        <sys_update_name>sys_script_include_9f6c5a5397bff5503c2d3f56f053af45</sys_update_name>
        <sys_updated_by>markus.kraus</sys_updated_by>
        <sys_updated_on>2024-01-29 00:45:52</sys_updated_on>
    </sys_script_include>
</record_update>
