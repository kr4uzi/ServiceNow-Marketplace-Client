<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>package_private</access>
        <active>true</active>
        <api_name>x_376096_mplc.MPLCImport</api_name>
        <caller_access/>
        <client_callable>false</client_callable>
        <description/>
        <mobile_callable>false</mobile_callable>
        <name>MPLCImport</name>
        <sandbox_callable>false</sandbox_callable>
        <script><![CDATA[/* global Uint8Array, Class, GlideScriptedExtensionPoint, GlideSysAttachment, GlideRecord, GlideStringUtil, XMLDocument2 */
/* global sn_ws, gs, sn_cc */
/* global x_376096_mplc */
/* eslint no-undef: "error" */
var MPLCImport = Class.create();
MPLCImport.prototype = {
	initialize: function () {
		this.jsLibs = new x_376096_mplc.JSLibs();
		this.gsa = new GlideSysAttachment();
		this.mplUtil = new x_376096_mplc.MPLCUtil();
		const eps = new GlideScriptedExtensionPoint().getExtensions('MPLCExt');
		if (eps.length) {
			eps[0].initialize();
			this.ext = eps[0];
		}
	},

	syncNOWStoreApp: function (conn, sourceID) {
		const result = {
			status: 'error',
			messages: []
		};

		const details = conn.data({
			action: 'store.Application.GetById',
			application_id: sourceID
		}).result;

		if (details.error) {
			result.messages.push(details.error);
			return result;
		}

		const appGr = new GlideRecord('x_376096_mplc_store_app');
		appGr.addQuery('source', this.mplUtil.CONN_ALIAS.NOW_STORE);
		appGr.addQuery('source_id', sourceID);
		appGr.setLimit(1);
		appGr.query();
		if (appGr.next()) {
			// use existing app
		} else {
			appGr.newRecord();
			appGr.source = this.mplUtil.CONN_ALIAS.NOW_STORE;
			appGr.source_id = sourceID;
		}

		appGr.name = details.title;
		appGr.description = details.store_description;
		appGr.url = conn.baseURL + '/sn_appstore_store.do#!/store/application/' + details.source_app_id;
		appGr.app_scope = details.scope;
		appGr.installed_version = '';
		appGr.latest_version = '';
		appGr.purchases = details.purchaseCount || 'NULL';
		appGr.downloads = details.trialCount || 'NULL';
		appGr.custom_tables = details.apprepo_custom_table_count || 'NULL';
		appGr.metadata = JSON.stringify({
			application_type: details.application_type
		});

		const appSysID = appGr.getUniqueValue();
		if (details.logo && this.ext) {
			const logoReq = conn.request(details.logo);
			logoReq.setHttpMethod('get');

			if (appGr.isNewRecord()) {
				// the insert needs to happend now, otherwise saveResponseBodyAsAttachment will throw
				appGr.insert();
			}

			logoReq.saveResponseBodyAsAttachment(appGr.getTableName(), appSysID, 'logo');
			const logoResp = logoReq.execute();
			if (logoResp.haveError()) {
				result.messages.push(`Failed to download ${details.logo}: ${logoResp.getErrorMessage()} (${logoResp.getErrorCode})`);
			} else {
				const attSysID = logoResp.getResponseAttachmentSysid();
				const success = this.ext.updateAttachment(attSysID, {
					table_name: 'ZZ_YY' + appGr.getTableName()
				});

				if (success) {
					if (appGr.logo) {
						// cleanup the previous logo
						// note: for security reasons the NOW Store implementation of this app does not offer a OAuth integration
						// because of this, we cannot get the logo's hash (via the now attachment api metadata endpoint)
						// this means that we re-download the application logos every time a app is synced
						this.gsa.deleteAttachment(appGr.logo);	
					}

					appGr.logo = attSysID;
				} else {
					this.gsa.deleteAttachment(attSysID);
					result.messages.push('Failed to set logo (please check for MPLCExt failure)');
				}
			}
		} else if (!details.logo && appGr.logo) {
			// remove and delete the logo if it doesn't exist in the store anymore
			this.gsa.deleteAttachment(appGr.logo);
			appGr.logo = '';
		}

		if (appGr.isNewRecord()) {
			appGr.insert();
		}

		const storeAppGr = new GlideRecord('sys_store_app');
		storeAppGr.addQuery('sys_id', sourceID);
		storeAppGr.setLimit(1);
		storeAppGr.query();

		let installedVersion = '';
		if (storeAppGr.next()) {
			installedVersion = storeAppGr.getValue('version');
		}

		details.versionsData.forEach(version => {
			const versionGr = new GlideRecord('x_376096_mplc_app_version');
			versionGr.addQuery('app', appSysID);
			versionGr.addQuery('version', version.store_version);
			versionGr.setLimit(1);
			versionGr.query();
			if (versionGr.next()) {
				// use existing app
			} else if (version.isWithdrawn && installedVersion != version.store_version) {
				// do not create new app version records for withdrawn versions (unless the version is installed)
				return;
			} else {
				versionGr.newRecord();
				versionGr.app = appSysID;
				versionGr.version = version.store_version;
				versionGr.target_table = 'sys_store_app';
			}

			versionGr.description = version.release_notes;

			const versionMetadata = {
				withdrawn: version.isWithdrawn,
				release_type: version.releaseType,
				publish_date: version.publish_date,
				is_latest: version.store_version == details.version
			};
			
			versionGr.metadata = JSON.stringify(versionMetadata);
			if (versionGr.isNewRecord()) {
				versionGr.insert();
			} else {
				versionGr.update();
			}

			const versionSysID = versionGr.getUniqueValue();
			if (versionGr.version == installedVersion) {
				appGr.installed_version = versionSysID;
			}

			if (versionMetadata.is_latest) {
				appGr.latest_version = versionSysID;
			}
		});

		// when the same GlideRecord has been 'insert()'-ed, a subsequent .update()
		// will actually force a db-update (even if no fields have changed)
		// (this is not the case if you re-initialize a gliderecord pointing to the same database row)
		if (appGr.getElements().some(e => e.changes())) {
			appGr.update();
		}

		result.status = result.messages.length == 0 ? 'success' : 'error';
		return result;
	},

	syncNOWStoreApps: function () {
		const conn = this.initNOWStoreConn();
		const apps = conn.data({
			action: 'store.Search.GetLatestListing'
		}).result;

		let count = 0;
		apps.forEach(base => {
			const res = this.syncNOWStoreApp(conn, base.source_app_id, base.logo);
			if (res.status != 'success') {
				gs.error(`Failed to sync Store App '${base.source_app_id}: ${res.messages.join('\n')}`);
			}
		});
	},

	syncNOWShareApp: function (conn, sourceID, metadata) {
		const result = {
			status: 'error',
			messages: []
		};

		const details = conn.data({
			action: 'share.project.details',
			data: {
				permalink: sourceID,
				t: 'PRODUCT_DETAILS'
			}
		}).result.data;

		if (details.error_message) {
			result.messages.push(details.error_message);
			return result;
		}

		sourceID = details.project.permalink;
		const appGr = new GlideRecord('x_376096_mplc_app');
		appGr.addQuery('source', this.mplUtil.CONN_ALIAS.NOW_SHARE);
		appGr.addQuery('source_id', sourceID);
		appGr.setLimit(1);
		appGr.query();
		if (appGr.next()) {
			// use existing app
		} else {
			appGr.newRecord();
			appGr.source = this.mplUtil.CONN_ALIAS.NOW_SHARE;
			appGr.source_id = sourceID;
		}

		appGr.name = details.project.title;
		appGr.description = GlideStringUtil.unescapeHTML(details.project.description);
		appGr.url = details.project.project_urls.urls.latest_version;
		appGr.installed_version = '';
		appGr.latest_version = '';
		if (metadata) {
			appGr.metadata = JSON.stringify(metadata);
		}

		if (appGr.isNewRecord()) {
			appGr.insert();
		}

		const appSysID = appGr.getUniqueValue();
		const activeVersionID = details.project.active_version;
		details.project.versions.forEach(version => {
			const versionGr = new GlideRecord('x_376096_mplc_app_version');
			versionGr.addQuery('app', appSysID);
			versionGr.addQuery('version', version.name);
			versionGr.setLimit(1);
			versionGr.query();
			if (versionGr.next()) {
				// use existing app
			} else {
				versionGr.newRecord();
				versionGr.app = appSysID;
				versionGr.version = version.name;
				versionGr.target_table = 'sys_update_set';
			}

			versionGr.description = GlideStringUtil.unescapeHTML(details.product_details[version.key].release_notes);
			versionGr.target = '';
			const versionMetadata = {
				is_latest: version.key == activeVersionID
			};

			let attSysID = '';
			const attGr = new GlideRecord('sys_attachment');
			attGr.addQuery('table_name', versionGr.getTableName());
			attGr.addQuery('table_sys_id', versionGr.getUniqueValue());
			attGr.addQuery('content_type', 'application/xml');
			attGr.orderByDesc('sys_created_on');
			attGr.setLimit(1);
			attGr.query();
			if (attGr.next()) {
				attSysID = attGr.getUniqueValue();
			}

			const updateSet = details.product_details[version.key].download_update_set;
			const hasError = result.messages.length > 0;
			if (!hasError && updateSet && conn.accessToken) {
				const attDataReq = new sn_ws.RESTMessageV2();
				attDataReq.setEndpoint(conn.baseURL + '/api/now/attachment/' + updateSet.link.match(/[?&]sys_id=([^&]+).*$/)[1]);
				attDataReq.setHttpMethod('get');
				attDataReq.setRequestHeader('Authorization', 'Bearer ' + conn.accessToken);
				attDataReq.setRequestHeader('Accept', 'application/json');
				const attDataResp = attDataReq.execute();
				if (attDataResp.haveError()) {
					result.messages.push(`Failed to retrieve Update Set Metadata for App Version ${version.name}: ${attDataResp.getErrorMessage()} (${attDataResp.getErrorCode()})`);
					conn.accessToken = '';
				} else {
					const attData = JSON.parse(attDataResp.getBody()).result;
					if (attData.hash) {
						const attGr = new GlideRecord('sys_attachment');
						attGr.addQuery('table_name', versionGr.getTableName());
						attGr.addQuery('table_sys_id', versionGr.getUniqueValue());
						attGr.addQuery('hash', attData.hash);
						attGr.setLimit(1);
						attGr.query();
						if (attGr.next()) {
							attSysID = attGr.getUniqueValue();
						} else {
							// force reload of the update set
							attSysID = '';
						}
					}

					if (!attSysID) {
						const attReq = new sn_ws.RESTMessageV2();
						attReq.setEndpoint(attData.download_link);
						attReq.setHttpMethod('get');
						attReq.setRequestHeader('Authorization', 'Bearer ' + conn.accessToken);

						if (versionGr.isNewRecord()) {
							// the insert needs to happend now, otherwise saveResponseBodyAsAttachment will throw
							versionGr.insert();
						}

						attReq.saveResponseBodyAsAttachment(versionGr.getTableName(), versionGr.getUniqueValue(), updateSet.file_name);
						
						const attResp = attReq.execute();
						if (attResp.haveError()) {
							result.messages.push(`Failed to retrieve Update Set Metadata for App Version ${version.name}: ${attResp.getErrorMessage()} (${attResp.getErrorCode()})`);
						} else {
							attSysID = attResp.getResponseAttachmentSysid();
						}
					}
				}
			}

			if (attSysID) {
				const doc = new XMLDocument2(this.gsa.getContentStream(attSysID));
				const usSysID = doc.getNodeText('/unload/sys_remote_update_set/sys_id');
				if (usSysID) {
					versionMetadata.update_set_type = 'remote';

					if (version.key == activeVersionID) {
						const logo = this.mplUtil.getLogoFromXMLDoc(doc);
						this.updateLogo(appGr, logo);

						appGr.app_sys_id = doc.getNodeText('/unload/sys_remote_update_set/application') || '';
						appGr.app_scope = doc.getNodeText('/unload/sys_remote_update_set/application_scope') || '';

						// todo: verify if overriding the name makes sense
						if (appGr.app_sys_id.startsWith('x_')) {
							// in case this is a custom app, we override the app's name (which by default is the project title for share-content)
							appGr.name = doc.getNodeText('/unload/sys_remote_update_set/application_name');
						}
					}

					let hash = 0;
					for (let node = doc.getFirstNode('/unload/sys_update_xml/payload_hash'); node; node = doc.getNextNode(node)) {
						// not sure if payload_hash can be empty (is an empty payload possible?)
						const payloadHash = node.getTextContent();
						if (payloadHash) {
							hash += parseInt(payloadHash);
						}
					}						

					const updateSetGr = new GlideRecord('sys_update_set');
					const cond = updateSetGr.addQuery('remote_sys_id', usSysID);
					if (hash) {
						versionGr.hash = String(hash);
						cond.addOrCondition('x_376096_mplc_hash', hash);
					} else {
						versionGr.hash = '';
					}
					
					updateSetGr.addQuery('state', 'complete');
					updateSetGr.setLimit(1);
					updateSetGr.query();
					if (updateSetGr.next()) {
						versionGr.target = updateSetGr.getUniqueValue();
					}
				} else {
					// some folks literally upload XML exports of the update set containing ony the sys_update_set xml-export
					// (instead of using the 'Export to XML' UI Action)
					versionMetadata.update_set_type = 'invalid';
				}
			}

			// given the versions are in ascending orders (which is typically the case),
			// the "installed_version" of the app record is overwritten with the latest
			// note: if this assumptions turns out to not be true, a simple glidequery after
			// this loop can identify and set latest_version
			if (versionMetadata.is_installed) {
				appGr.installed_version = versionGr.getUniqueValue();
			}

			if (version.key == activeVersionID) {
				appGr.latest_version = versionGr.getUniqueValue();
			}

			versionGr.metadata = JSON.stringify(versionMetadata);

			if (versionGr.isNewRecord()) {
				versionGr.insert();
			} else if (versionGr.getElements().some(e => e.changes())) {
				versionGr.update();
			}
		});

		if (appGr.getElements().some(e => e.changes())) {
			appGr.update();
		}

		result.status = result.messages.length == 0 ? 'success' : 'error';
		return result;
	},

	syncNOWShareApps: function () {
		const conn = this.initNOWShareConn();
		// Access Token is optional but enables Update Set Download
		let accessToken = new sn_cc.StandardCredentialsProvider()
			.getCredentialByAliasID(this.mplUtil.CONN_ALIAS.NOW_SHARE)
			?.getAttribute('api_key');

		let page = 1;
		while (page > 0) {
			const pageData = conn.data({
				action: 'share.all.apps.list',
				data: {
					page: page
				}
			});

			if (pageData.result.status != 'success') {
				gs.error('Unsuccessfull: ' + JSON.stringify(pageData, null, 2));
				break;
			}

			const resultData = pageData.result.data;
			if (page++ >= (resultData.pagination.total_pages || 0)) {
				break;
			}

			resultData.projects.forEach(project => {
				// Note: Unfortunately the share.all.apps.list api doesn't include the project identifiers.
				// They have to be parsed using URLSearchParams (which isn't available in ServiceNow JavaScript)
				// or using an regex method below (which is also how the NOW implementation of the developer portal does it)
				const sourceID = project.url.match(/contents\/([^?$]+)(\?|$)/)[1];
				const res = this.syncNOWShareApp(conn, sourceID, {
					created: project.created_on,
					category: project.category,
					product: project.product,
					downloads: project.downloads,
					overall_rating: project.overall_rating,
					total_ratings: project.total_ratings,
					updated: project.owner_last_updated_on
				});

				if (res.status == 'error') {
					gs.error(`Failed to sync Share App '${sourceID}: ${res.messages.join('\n')}`);
				}
			});
		}
	},

	_initConn: function (instanceURL, aliasSysID, requestPage) {
		if (instanceURL.endsWith('/')) {
			throw new Error('instanceURL must not end with a /');
		}

		const userTokenReq = new sn_ws.RESTMessageV2();
		userTokenReq.setHttpMethod('get');
		userTokenReq.setEndpoint(instanceURL + '/login.do');
		const userTokenResp = userTokenReq.execute();
		if (userTokenResp.haveError()) {
			throw new Error(`Failed to initialize connection: ${userTokenResp.getErrorMessage()} (${userTokenResp.getErrorCode()})`);
		}

		const userToken = getUserToken(userTokenResp);
		if (!userToken) {
			throw new Error('Failed to initialize connection: no UserToken present in login.do');
		}

		const cookies = {};
		parseCookies(cookies, userTokenResp);

		const accessToken = new sn_cc.StandardCredentialsProvider()
				.getCredentialByAliasID(aliasSysID)
				?.getAttribute('api_key');

		const NOWConn = function () {
			this.baseURL = instanceURL;
			this.accessToken = accessToken;
		};
		NOWConn.prototype.data = function (jsonData) {
			const dataReq = this.request(requestPage + '?sysparm_data=' + encodeURI(JSON.stringify(jsonData)));
			dataReq.setHttpMethod('get');
			const dataResp = dataReq.execute();
			if (dataResp.getStatusCode() == 200) {
				return JSON.parse(dataResp.getBody());
			}
		};
		NOWConn.prototype.request = function (resource) {
			const req = new sn_ws.RESTMessageV2();
			setCookie(cookies, req);
			req.setRequestHeader('X-UserToken', userToken);
			req.setEndpoint(this.baseURL + '/' + resource);
			return req;
		};

		return new NOWConn();

		function parseCookies(cookies, resp) {
			const filterCookies = ['JSESSIONID', 'glide_user_route', 'glide_user', 'glide_user_session', 'glide_node_id_for_js'];
			resp.getAllHeaders()
				.filter(header => header.name == 'Set-Cookie')
				.forEach(header => {
					const value = header.value.substring(0, header.value.indexOf(';')).split('=');
					if (filterCookies.includes(value[0]) || value[0].startsWith('BIGipServerpool')) {
						cookies[value[0]] = value[1];
					}
				});
		}

		function setCookie(cookies, req) {
			req.setRequestHeader('Cookie',
				Object.entries(cookies)
					.map(([name, value]) => name + '=' + value)
					.join(';')
			);
		}

		function getUserToken(resp) {
			const formHeader = resp.getHeader('X-UserToken');
			if (formHeader) {
				return formHeader;
			}

			const body = resp.getBody();
			const singleQuotes = body.match(/var g_ck = '(.*?)';/);
			if (singleQuotes) {
				return singleQuotes[1];
			}

			const doubleQuotes = body.match(/var g_ck = "(.*?)";/);
			if (doubleQuotes) {
				return doubleQuotes[1];
			}
		}
	},

	initNOWStoreConn: function () {
		return this._initConn('https://store.servicenow.com', this.mplUtil.CONN_ALIAS.NOW_STORE, 'appStore.do');
	},

	initNOWShareConn: function () {
		return this._initConn('https://developer.servicenow.com', this.mplUtil.CONN_ALIAS.NOW_SHARE, 'devportal.do');
	},

	syncGITApps: function () {
		const aliasGr = new GlideRecord('sys_alias');
		aliasGr.addQuery('parent', this.mplUtil.CONN_ALIAS.GIT);
		aliasGr.query();
		while (aliasGr.next()) {
			const appResult = this.mplUtil.getGitRepos(aliasGr.sys_id);
			if (appResult.status != 'success') {
				continue;
			}

			appResult.repositories.forEach(appData => {
				const appGr = new GlideRecord('x_376096_mplc_app');
				appGr.addQuery('source', aliasGr.sys_id);
				appGr.addQuery('source_id', appData.git.id);
				appGr.setLimit(1);
				appGr.query();
				if (appGr.next()) {
					// use existing app
				} else {
					appGr.newRecord();
					appGr.source = aliasGr.sys_id;
					appGr.source_id = appData.git.id;
				}

				this.updateLogo(appGr, appData.app.logo);

				appGr.name = appData.app.name;
				appGr.description = appData.app.short_description;
				appGr.url = appData.git.html_url;
				appGr.app_scope = appData.app.scope;
				appGr.metadata = JSON.stringify({
					version: appData.app.version,
					created: appData.app.created,
					updated: appData.app.updated,
					store_url: appData.app.store_url
				});

				if (appGr.isNewRecord()) {
					appGr.insert();
				} else {
					appGr.update();
				}
			});
		}
	},

	updateLogo: function (appGr, logoData) {
		if (logoData) {
			const attGr = new GlideRecord('sys_attachment');
			attGr.addQuery('sys_id', appGr.logo);
			attGr.setLimit(1);
			attGr.query();
			if (attGr.next()) {
				if (attGr.hash == logoData.hash) {
					// logo didn't change
					return;
				}

				this.gsa.deleteAttachment(attGr.sys_id);
			}
		}

		appGr.logo = '';

		if (this.ext && logoData) {
			const Base64 = this.jsLibs.require('Base64');

			const data = [];
			logoData.content_base64.forEach(str => Base64.atob(str).split('').forEach(x => data.push(x.charCodeAt(0))));
			const bytes = new Uint8Array(data);

			let logoBase64 = '';
			if (logoData.compressed) {
				const gzip = this.jsLibs.require('gzip');
				const decompressed = new Uint8Array(gzip.unzip(bytes));
				logoBase64 = Base64.fromUint8Array(decompressed);
			} else {
				logoBase64 = Base64.fromUint8Array(bytes);
			}

			let attSysID = this.gsa.writeBase64(appGr, 'logo', logoData.content_type, logoBase64);
			if (attSysID) {
				const success = this.ext.updateAttachment(attSysID, {
					table_name: 'ZZ_YY' + appGr.getTableName(),
					content_type: logoData.content_type
				});

				if (success) {
					appGr.logo = attSysID;
				} else {
					this.gsa.deleteAttachment(attSysID);
				}
			}
		}
	},

	type: 'MPLCImport'
};]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>markus.kraus</sys_created_by>
        <sys_created_on>2024-08-11 08:03:57</sys_created_on>
        <sys_id>1b95290493041210e02873718bba10a2</sys_id>
        <sys_mod_count>103</sys_mod_count>
        <sys_name>MPLCImport</sys_name>
        <sys_package display_value="Marketplace Client" source="x_376096_mplc">2fe28b4497bf39103c2d3f56f053af4e</sys_package>
        <sys_policy/>
        <sys_scope display_value="Marketplace Client">2fe28b4497bf39103c2d3f56f053af4e</sys_scope>
        <sys_update_name>sys_script_include_1b95290493041210e02873718bba10a2</sys_update_name>
        <sys_updated_by>markus.kraus@intrux.ch</sys_updated_by>
        <sys_updated_on>2025-08-20 19:48:15</sys_updated_on>
    </sys_script_include>
</record_update>
